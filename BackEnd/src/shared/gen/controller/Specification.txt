import {
	JsonController,
	Param,
	Body,
	Get,
	Post,
	Put,
	Delete,
	Req,
	UseBefore,
	Patch,
} from "routing-controllers";
import { AppDataSource } from "../../../../shared/db/data-source";
import { Planning } from "../../../../shared/Entity/PlanningEntity";
import { Project } from "../../../../shared/Entity/ProjectEntity";
import { Team } from "../../../../shared/Entity/TeamEntity";
import { Specification } from "../../../../shared/Entity/SpecificationEntity";
import { CheckAuth } from "../../../../shared/MiddleWare/Auth";
import { User } from "../../../../shared/Entity/UserEntity";

import "reflect-metadata";

import axios from "axios";
import * as fs from "fs";
import * as dotenv from "dotenv";
import { Ticket } from "../../../../shared/Entity/TicketEntity";
dotenv.config();

// TODO: Retourner un statut pending tant que l'ia n'as aps terminé de créer un

/**
 * Traite une string pour y extirper toutes les dates
 * @param {string} input
 * @param {string} startDateString
 * @returns {Date[]}
 */
function parseDurations(input: string, startDateString: string): Date[] {
	const durations: Date[] = [];

	const startDate = new Date(startDateString);

	// Define mappings for different units
	const unitMappings: { [key: string]: string } = {
		semaine: "week",
		semaines: "weeks",
		week: "week",
		weeks: "weeks",
		jour: "day",
		jours: "days",
		day: "day",
		days: "days",
		j: "day",
		d: "days",
		heures: "hour",
		heure: "hour",
		hour: "hour",
		hours: "hours",
		h: "hours",
	};

	// Regular expression to match each duration entry
	const regex = /(\d+)\s*([a-zA-Z]+)/g;

	// Match all duration entries in the input string
	let match;
	while ((match = regex.exec(input)) !== null) {
		const value = parseInt(match[1]);
		const unit = unitMappings[match[2].toLowerCase()];

		if (!isNaN(value) && unit) {
			let newDate: Date;

			switch (unit) {
				case "week":
				case "weeks":
					newDate = new Date(
						startDate.getTime() + value * 7 * 24 * 60 * 60 * 1000
					);
					break;
				case "day":
				case "days":
					newDate = new Date(
						startDate.getTime() + value * 24 * 60 * 60 * 1000
					);
					break;
				case "hour":
				case "hours":
					newDate = new Date(
						startDate.getTime() + value * 60 * 60 * 1000
					);
					break;
				default:
					continue; // Unsupported unit
			}

			durations.push(newDate);
		}
	}

	return durations;
}

/**
 * Créé des tickets pour chaque date trouvé dans l'échéancier
 * @param {Project} params
 * @param {Project} project_input
 * @param {Planning} planning_input
 * @param {User} user
 * @param {any} planningRepository
 * @param {any} ticketRepository
 */
async function createTicket(
	params: Project,
	project_input: Project,
	planning_input: Planning,
	user: User,
	planningRepository: any,
	ticketRepository: any
) {
	//On traite l'échéance pour ne récuperer que les dates
	const resultArray = parseDurations(
		params.getForecast(),
		JSON.stringify(project_input.getStartDate())
	);
	let forecastarray = params.getForecast().split(/[;,]/);

	//On recherche l'id du planning pour l'attribuer au nouveau projet
	const planning: Planning = await planningRepository.findOne({
		where: { id: planning_input.getId() },
	});
	if (!planning) throw new Error("Planning not found");

	//On créé un ticket pour chaque date trouvé
	if (resultArray.length > 0) {
		resultArray.forEach(async (date, index) => {
			const ticket: Ticket = new Ticket(
				forecastarray[index], // title
				"", // description
				0, // urgenceId
				"ouvert", // status
				planning.getId(), // planningId
				project_input.getStartDate(), // start_date
				date // end_date
			);
			ticket.setUser(user);
			ticket.setPlanning(planning);
			await ticketRepository.save(ticket);
			console.log(`Ticket ${index + 1} créé: ${ticket.getId()}`);
		});
	} else {
		console.log("Pas de durée trouvé, pas de ticket créé");
	}
}
@JsonController()
export class SpecificationController {
	constructor(
		private planningRepository,
		private projectRepository,
		private specificationRepository,
		private teamRepository,
		private userRepository,
		private ticketRepository
	) {
		this.planningRepository = AppDataSource.getRepository(Planning);
		this.projectRepository = AppDataSource.getRepository(Project);
		this.specificationRepository =
			AppDataSource.getRepository(Specification);
		this.teamRepository = AppDataSource.getRepository(Team);
		this.userRepository = AppDataSource.getRepository(User);
		this.ticketRepository = AppDataSource.getRepository(Ticket);
	}

	/**
	 * @swagger
	 * /project/{teamid}/{userid}:
	 *   post:
	 *     tags:
	 *       - Specification
	 *     summary: Create a new project
	 *     security:
	 *       - bearerAuth: []
	 *     parameters:
	 *       - in: path
	 *         name: teamid
	 *         required: true
	 *         schema:
	 *           type: string
	 *         description: The team ID
	 *       - in: path
	 *         name: userid
	 *         required: true
	 *         schema:
	 *           type: string
	 *         description: The user ID
	 *     requestBody:
	 *       required: true
	 *       content:
	 *         application/json:
	 *           schema:
	 *             type: object
	 *             properties:
	 *               name:
	 *                 type: string
	 *               description:
	 *                 type: string
	 *               functionality:
	 *                 type: string
	 *               forecast:
	 *                 type: string
	 *               startDate:
	 *                 type: string
	 *                 format: date
	 *               endDate:
	 *                 type: string
	 *                 format: date
	 *               budget:
	 *                 type: number
	 *               technology:
	 *                 type: string
	 *               constraints:
	 *                 type: string
	 *               validation:
	 *                 type: string
	 *               teamUser:
	 *                 type: string
	 *     responses:
	 *       200:
	 *         description: Project created
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 success:
	 *                   type: string
	 *       default:
	 *         description: Unexpected error
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 error:
	 *                   type: string
	 */
	@Post("/project/:teamid/:userid")
	@UseBefore(CheckAuth)
	/**
	 * Creates a new project.
	 *
	 * @param params - The project parameters.
	 * @param req - The request object.
	 * @param teamid - The team ID.
	 * @param userid - The user ID.
	 * @returns A success message if the project is created, or an error message if there is an error.
	 */
	public async newproject(
		@Body() params: Project,
		@Req() req: any,
		@Param("teamid") teamid: string,
		@Param("userid") userid: string
	) {
		//On recherche l'id de la team pour l'attribuer au nouveau projet
		const team: Team = await this.teamRepository.findOne({
			where: { id: teamid },
		});
		if (!team) throw new Error("Team not found");

		//On recherche l'id de l'user pour l'attribuer au nouveau projet
		const user: User = await this.userRepository.findOne({
			where: { id: userid },
		});
		if (!user) throw new Error("User not found");

		const project: Project = await this.projectRepository.find({
			where: { user: { id: userid } },
		});
		let project_nbr = Object.keys(project).length;

		//On initie project_input qu'on rentrera en base de donnée
		var project_input: Project = params;
		project_input.setTeam(team);
		project_input.setUser(user);

		//On initie specification_input qu'on entre en base de donnée en attendant la réponse de l'ia
		var specification = "Données en attente";
		var specification_input: Specification = new Specification(
			specification
		);
		specification_input.setTeam(team);
		specification_input.setUser(user);
		project_input.setColor(project_nbr++);

		await this.projectRepository.save(project_input);
		console.log(`Projet créé: ${project_input.getId()}`);
		try {
			//On créé la requete a l'ia
			const dataread = await fs.promises.readFile(
				`../template/${params.getTemplate()}.txt`,
				"utf8"
			);
			let content =
				"La génération doit etre en HTML. En suivant ce plan: " +
				dataread +
				" Génère un cahier des charges comme si un humain l'avais rédigé en ajoutant des informations correspondant au projet et en developpant d'avantage le projet pour remplir toutes les catégories pour un projet appelé " +
				params.getName() +
				". Description du projet: " +
				params.getDescription() +
				". Développe d'avantage la description du projet et justifie le besoin de ce projet. Liste des fonctionnalités: " +
				params.getFunctionality() +
				". Developpe la rédatio autour de ces fonctionnalité. Planning prévisionnel: " +
				params.getForecast() +
				". Date de début: " +
				params.getStartDate() +
				". Date de fin: " +
				params.getEndDate() +
				". Budget: " +
				params.getBudget() +
				". Estimme comment ce budget va etre dépensé et justifie le. Technologies du projet: " +
				params.getTechnology() +
				". Jusitifie le choix de ses technologies dans un developpement complet. Les contraintes techniques: " +
				params.getConstraints() +
				". Condition de validation du projet: " +
				params.getValidation() +
				". Chef de projet: " +
				user.getFirstname() +
				" " +
				user.getLastname() +
				". Nom de l'équipe: " +
				team.getName() +
				". Chaque membre de l'équipe et leurs role: " +
				params.getTeamUser();

			//on definie le model et le message à l'ia
			const data = {
				model: process.env.IA_MODEL,
				messages: [{ role: "user", content: content }],
				temperature: 0,
			};

			//On prépare la configuration avec la clef d'api openia et le type
			const config = {
				headers: {
					"Content-Type": "application/json",
					Authorization: `Bearer ${process.env.API_KEY}`,
				},
			};

			//on definie le model de backup et le message à l'ia
			const databackup = {
				model: process.env.BACKUP_IA_MODEL,
				messages: [{ role: "user", content: content }],
				temperature: 0,
			};

			//On prépare la configuration avec la clef d'api backup et le type
			const configbackup = {
				headers: {
					"Content-Type": "application/json",
					Authorization: `Bearer ${process.env.BACKUP_API_KEY}`,
				},
			};

			// Requete axios a l'api open ai
			console.log("requete ia");
			axios
				.post(process.env.IA_URL, data, config)
				.then((response) => {
					console.log(response.data.choices[0].message.content);
					specification = response.data.choices[0].message.content;
					specification = specification.replace(/```html/g, "");
					specification = specification.split("```")[0];
					specification_input.setSpecification(specification);
					specification_input.setProject(project_input);
					this.specificationRepository.save(specification_input);
					console.log(`Cahier des charges créé`);
					return specification;
				})
				.catch(async (error) => {
					console.error("Error:", error);
					// If the first request fails, try a backup URL
					console.log("Backup request ia");
					try {
						const backupResponse = await axios.post(
							process.env.BACKUP_IA_URL,
							databackup,
							configbackup
						);
						console.log(
							backupResponse.data.choices[0].message.content
						);
						specification =
							backupResponse.data.choices[0].message.content;
						specification_input.setSpecification(specification);
						specification_input.setProject(project_input);
						this.specificationRepository.save(specification_input);
						console.log(`Cahier des charges créé (backup)`);
						return specification;
					} catch (backupError) {
						console.error("Backup Error:", backupError);
						// Handle the backup error appropriately (e.g., throw, log, or return a default value).
					}
				});

			//On initie planning_input qu'on rentrera en base de donnée
			const planning_input: Planning = new Planning(
				params.getStartDate(),
				params.getEndDate()
			);
			planning_input.setProject(project_input);
			if (!planning_input) throw new Error("Planning not created");
			await this.planningRepository.save(planning_input);
			console.log(`Planning créé: ${planning_input.getId()}`);

			//on appelle la fonction de création de ticket
			createTicket(
				params,
				project_input,
				planning_input,
				user,
				this.planningRepository,
				this.ticketRepository
			);

			return { success: "Création du projet" };
		} catch (error) {
			return { error: error.message };
		}
	}

	/**
	 * @swagger
	 * /specification/{id}:
	 *   get:
	 *     tags:
	 *       - Specification
	 *     summary: Retrieve a single Specification entity by its ID
	 *     security:
	 *       - bearerAuth: []
	 *     parameters:
	 *       - in: path
	 *         name: id
	 *         schema:
	 *           type: string
	 *         required: true
	 *         description: The ID of the Specification entity
	 *     responses:
	 *       200:
	 *         description: The retrieved Specification entity if found
	 *         content:
	 *           application/json:
	 *             schema:
	 *               $ref: '#/components/schemas/Specification'
	 *       default:
	 *         description: Unexpected error
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 error:
	 *                   type: string
	 */
	@Get("/specification/:id")
	@UseBefore(CheckAuth)
	/**
	 * Retrieves a single Specification entity by its ID.
	 * @param id - The ID of the Specification entity.
	 * @returns The retrieved Specification entity if found, otherwise an error object.
	 */
	public async getOne(@Param("id") id: string) {
		try {
			const specification: Specification =
				await this.specificationRepository.findOne({
					where: { id },
				});
			if (!specification) throw new Error("Specification not found");
			return specification;
		} catch (err) {
			return { error: err.message };
		}
	}

	/**
	 * @swagger
	 * /specification/user/{userid}:
	 *   get:
	 *     tags:
	 *       - Specification
	 *     summary: Retrieves all Specifications associated with a specific user
	 *     security:
	 *       - bearerAuth: []
	 *     parameters:
	 *       - in: path
	 *         name: userid
	 *         schema:
	 *           type: string
	 *         required: true
	 *         description: The ID of the user
	 *     responses:
	 *       200:
	 *         description: A Specification object
	 *         content:
	 *           application/json:
	 *             schema:
	 *               $ref: '#/components/schemas/Specification'
	 *       default:
	 *         description: Unexpected error
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 error:
	 *                   type: string
	 */
	@Get("/specification/user/:userid")
	@UseBefore(CheckAuth)
	/**
	 * Retrieves all Specifications associated with a specific user.
	 * @param userid - The ID of the user.
	 * @returns A Promise that resolves to the retrieved Specifications or an error object.
	 */
	public async getAllSpecificationByUser(@Param("userid") userid: string) {
		try {
			const specification: Specification =
				await this.specificationRepository.find({
					where: { user: { id: userid } },
				});
			if (!specification) throw new Error("Specification not found");
			return specification;
		} catch (err) {
			return { error: err.message };
		}
	}

	/**
	 * @swagger
	 * /specification/project/{projectid}:
	 *   get:
	 *     tags:
	 *       - Specification
	 *     summary: Retrieves all Specifications associated with a specific project
	 *     security:
	 *       - bearerAuth: []
	 *     parameters:
	 *       - in: path
	 *         name: projectid
	 *         required: true
	 *         schema:
	 *           type: string
	 *         description: The ID of the project
	 *     responses:
	 *       200:
	 *         description: A Specification object
	 *         content:
	 *           application/json:
	 *             schema:
	 *               $ref: '#/components/schemas/Specification'
	 *       default:
	 *         description: Unexpected error
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 error:
	 *                   type: string
	 */
	@Get("/specification/project/:projectid")
	@UseBefore(CheckAuth)
	/**
	 * Retrieves all Specifications associated with a specific project.
	 * @param projectid - The ID of the project.
	 * @returns A Promise that resolves to the retrieved Specifications, or an error object if not found.
	 */
	public async getAllSpecificationByProject(
		@Param("projectid") projectid: string
	) {
		try {
			const specification: Specification =
				await this.specificationRepository.findOne({
					where: { project: { id: projectid } },
				});
			if (!specification) throw new Error("Specification not found");
			return specification;
		} catch (err) {
			return { error: err.message };
		}
	}

	/**
	 * @swagger
	 * /specification/{id}:
	 *   delete:
	 *     tags:
	 *       - Specification
	 *     summary: Removes a Specification by its ID
	 *     security:
	 *       - bearerAuth: []
	 *     parameters:
	 *       - in: path
	 *         name: id
	 *         required: true
	 *         schema:
	 *           type: string
	 *         description: The ID of the Specification to remove
	 *     responses:
	 *       200:
	 *         description: Specification deleted
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 success:
	 *                   type: string
	 *       default:
	 *         description: Unexpected error
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 error:
	 *                   type: string
	 */
	@Delete("/specification/:id")
	@UseBefore(CheckAuth)
	/**
	 * Removes a Specification by its ID.
	 * @param id - The ID of the Specification to remove.
	 * @returns A promise that resolves to an object with a success property if the Specification is deleted successfully, or an error property if an error occurs.
	 */
	public async remove(@Param("id") id: string) {
		try {
			const specification: Specification =
				await this.specificationRepository.findOne({
					where: { id },
				});
			if (!specification) throw new Error("Specification not found");
			await this.specificationRepository.remove(specification);
			return { success: "Specification deleted" };
		} catch (err) {
			return { error: err.message };
		}
	}

	/**
	 * @swagger
	 * /specification/{id}:
	 *   patch:
	 *     tags:
	 *       - Specification
	 *     summary: Update a Specification record
	 *     security:
	 *       - bearerAuth: []
	 *     parameters:
	 *       - in: path
	 *         name: id
	 *         required: true
	 *         schema:
	 *           type: string
	 *         description: The id of the Specification record to update
	 *     requestBody:
	 *       required: true
	 *       content:
	 *         application/json:
	 *           schema:
	 *             $ref: '#/components/schemas/Specification'
	 *     responses:
	 *       200:
	 *         description: Specification record updated
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 success:
	 *                   type: string
	 *       default:
	 *         description: Unexpected error
	 *         content:
	 *           application/json:
	 *             schema:
	 *               type: object
	 *               properties:
	 *                 error:
	 *                   type: string
	 */
	@Patch("/specification/:id")
	@UseBefore(CheckAuth)
	/**
	 * Updates a Specification record with the specified id.
	 * @param id - The id of the Specification record to update.
	 * @param data - The updated data for the Specification record.
	 * @returns An object indicating the success or error message.
	 */
	public async update(@Param("id") id: string, @Body() data: Specification) {
		try {
			const specification: Specification =
				await this.specificationRepository.findOne({
					where: { id },
				});
			if (!specification) throw new Error("Specification not found");

			await this.specificationRepository.save({
				...specification,
				...data,
			});
			return { success: "Specification updated" };
		} catch (err) {
			return { error: err.message };
		}
	}
}
